{
  "hash": "fde4569a988864748230a8475a30ed97",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Transformation\"\nnumber-sections: true\n---\n\n\n## Clear Workspace, DON'T EDIT {-}\n\nAlways start by clearing the workspace. This ensure objects created in other files are not used used here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\n## List Used Packages, EDIT {-}\n\nList all the packages that will be used in chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackages = c(\"nycflights13\", \"ggplot2\", \"dplyr\")\n```\n:::\n\n\n\n## Load Packages, DON'T EDIT {#sec-packages -}\n\n### Install Missing {-}\n\nAny missing package will be installed automatically. This ensure smoother execution when run by others.\n\n::: callout-important\n\n#### Installing Packages on Other People Machine\n\nBe aware the people may not like installing packages into their machine automatically.  This might break some of their previous code.\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Do NOT modify\ninstall.packages(setdiff(packages, rownames(installed.packages())))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nInstalling package into 'C:/Users/Amin Alhashim/AppData/Local/R/win-library/4.4'\n(as 'lib' is unspecified)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError in contrib.url(repos, \"source\"): trying to use CRAN without setting a mirror\n```\n\n\n:::\n:::\n\n\n### Load {-}\n\nLoad all packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Do NOT modify\nlapply(packages, require, character.only = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: nycflights13\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: dplyr\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] TRUE\n\n[[2]]\n[1] TRUE\n\n[[3]]\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n## Introduction\n\nThis page introduces the `dplyr` package used to transform data such as creating new variables, editing existing variables, filtering out observations, and creating summaries.\n\n\n\n## `dplyr` Functions (Verbs)\n\n### Four Groups\n\n`dplyr` functions (verbs) can be grouped into functions that work on:\n\n-   rows, eg, `filter()`, `arrange()`, `distinct()`, `count()`\n-   columns, eg, `mutate()`, `select()`, `rename()`, `relocate()`\n-   groups, eg, `summarize()`, `slice_max`, `group_by`, `ungroup()`, `.by`\n-   tables\n\n### Common Characteristics\n\nAll the functions have the followings in common:\n\n-   their first argument is always a data frame\n-   their subsequent arguments typically describe which columns to operate on using variable names *without quotes*\n-   they always output a new data frame, they don't modify the passed one\n\n### Pipe `|>` Operator\n\n-   The pipe `|>` operator takes what on its left and pass it to the function on its right so that `x |> f(y)` (pronounced as `x` *then* `f(y)`) is equivalent to `f(x, y)` and `x |> f(y) |> g(z)` (pronounced as `x` then `f(y)` then `g(z)`) is equivalent to `g(f(x, y), z)`\n-   The `base` R pipe operator `|>` was introduced in R 4.1.0 in 2021 while the tidyverse `magrittr` pipe operator `%>%` was introduced in 2014. Using `|>` instead of `%>%` makes our code run when we don't use tidyverse\n\n### Row Functions\n\n-   The following `filter()` statements are equivalent:\n    -   `filter(ds, var == 1 or var == 2)`\n    -   `filter(ds, var == 1 | var == 2)`\n    -   `filter(ds, var %in% c(1,2))`\n-   The following `filter()` statements are equivalent:\n    -   `filter(ds, var == 1 and var == 2)`\n    -   `filter(ds, var == 1, var == 2)`\n-   The following `arrange()` statements order data differently\n    -   `arrange(ds, var)` ascendant order\n    -   `arrange(ds, desc(var))` decedent order\n-   The following `distinct()` statements return different data frames\n    -   `distinct(ds, var1, var2)` only keep columns `var1` and `var2`\n    -   `distinct(ds, var1, var2, .keep_all = TRUE)` keep all the columns--find the *first* observation where `var1` and `var2` are distinct and discard the rest\n-   The following `count()` statements order the results differently\n    -   `count(ds, var1, var2)` arrange results in order they are encountered\n    -   `count(ds, var1, var2, sort = TRUE)` arrange results in descending order of number of occurrence\n\n### Column Functions\n\n-   `mutate()`\n    -   Instead of adding the newly created variable to the right hand side of the data frame, we can instruct `mutate()` to adding before a variable using the `.before` attribute or after a variable using the `.after` attribute\n    -   To only keep the variables involved in the creation of the new variables, we can instruct `mutate()` to do so by setting the `.keep = \"used\"` attribute\n-   `select()`\n    -   select range of variables: `select(ds, var_x:var_y)`\n    -   select all variables except certain range: `select(ds, !var_x:var_y)`\n    -   select character variables only: `select(ds, where(is.character))`\n    -   select variables whose name start with something: `select(ds, start_with(\"m\"))`\n    -   select variables whose name end with something: `select(ds, end_with(\"m\"))`\n    -   select variables whose name contain something: `select(ds, contains(\"m\"))`\n    -   select variables whose name follow some range: `select(ds, num_range(\"x\", 1:3))`\n    -   select and rename variable: `select(ds, var1_new = var1, var2_new = var2)`\n-   `rename()`\n    -   to rename many columns, it is better to use `janitor::clean_names()` function\n-   `relocate()`\n    -   By default, bring columns to left hand side of the data frame\n    -   `relocate(ds, var1, .after = var2)` puts `var1` after `var2`\n    -   `relocate(ds, var1, .before = var2)` puts `var1` before `var2`\n\n### Groups Functions\n\n-   `group_by()`\n    -   divides the data into groups so that subsequent operations work on these groups\n    -   it added a *class* to the dataset to indicate the grouping\n\n-   `summarize()` or `summarise()`\n    -   To prevent summary statistics functions, eg, `mean()` to give `NA` due to some groups has `NA` (missing) values, set their argument:  `na.rm = TRUE`\n    -   The summary statistics function `n()` gives the number of observations in the group\n    -   Each summary peels off the last group.  To prevent this behavior, change the default value `drop_last` of the `.groups` argument of the summary statistic function to either `keep` to keep all groups or `drop` to drop all groups\n\n-     `slice_` functions\n    -   The functions are: `slice_head()`, `slice_tail()`, `slice_min()`, `slice_max()`, and `slice_sample()`\n    -   To slice a number of rows from each group, use the `n` arguments, eg, `n = 1`\n    -   To slice percentage of rows from each group, use the `prop` argument, eg, `prop = .1` (10%)\n    -   To prevent ties from showing, use `with_ties = FALSE` argument\n\n-     `.by` argument\n    -   New addition to dplyr 1.1.0 (more information at [dplyr 1.1.0 blog post](https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-per-operation-grouping/))\n    -   Per-operation grouping--can be used all verbs.  The advantage is that we don't need to use the `.groups` argument to suppress the warning message raised by `summarize()` when grouping by multiple variables and we don't need to use `ungroup()` when done with our summary.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}